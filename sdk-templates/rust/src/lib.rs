//! Functions.do Rust SDK Template
//!
//! This template provides the foundation for building serverless functions
//! with the Functions.do platform using Rust compiled to WebAssembly.
//!
//! # Usage
//!
//! Define your functions using the `#[functions_do]` attribute macro,
//! or use the lower-level `#[wasm_bindgen]` and `#[no_mangle]` exports.
//!
//! # Example
//!
//! ```rust
//! use wasm_bindgen::prelude::*;
//!
//! #[wasm_bindgen]
//! pub fn add(a: i32, b: i32) -> i32 {
//!     a + b
//! }
//! ```

use wasm_bindgen::prelude::*;

// Re-export wasm_bindgen for convenience
pub use wasm_bindgen;

/// capnweb-style RPC target marker trait
///
/// Implement this trait on your structs to enable RPC-style invocation
/// through the Functions.do platform.
pub trait RpcTarget {
    /// Returns the list of callable methods on this target
    fn methods() -> &'static [&'static str];

    /// Invoke a method by name with JSON-encoded arguments
    fn invoke(&mut self, method: &str, args: &str) -> Result<String, String>;
}

/// Marker for functions that should be exported to the capnweb binding layer
pub trait CapnwebExport {
    /// The function's unique identifier for binding generation
    const FUNCTION_ID: &'static str;

    /// Parameter types as a tuple type signature
    type Params;

    /// Return type
    type Returns;
}

// ============================================================================
// Example implementations - Replace with your own functions
// ============================================================================

/// Simple addition function
///
/// This demonstrates a basic numeric function that can be called from
/// the Functions.do platform.
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// Subtract two numbers
#[wasm_bindgen]
pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

/// Multiply two numbers
#[wasm_bindgen]
pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

/// Identity function - returns the input unchanged
#[wasm_bindgen]
pub fn identity(x: i32) -> i32 {
    x
}

/// Get a constant answer
#[wasm_bindgen]
pub fn get_answer() -> i32 {
    42
}

// ============================================================================
// Low-level C FFI exports for direct WASM instantiation
// These bypass wasm-bindgen for minimal overhead
// ============================================================================

/// Raw C FFI export for addition
#[no_mangle]
pub extern "C" fn raw_add(a: i32, b: i32) -> i32 {
    a + b
}

/// Raw C FFI export for subtraction
#[no_mangle]
pub extern "C" fn raw_subtract(a: i32, b: i32) -> i32 {
    a - b
}

/// Raw C FFI export for multiplication
#[no_mangle]
pub extern "C" fn raw_multiply(a: i32, b: i32) -> i32 {
    a * b
}

// ============================================================================
// capnweb integration stubs
// These will be generated by the Functions.do build process
// ============================================================================

/// Capnweb message buffer for efficient serialization
/// Uses a simple length-prefixed format compatible with Cap'n Proto style
#[wasm_bindgen]
pub struct CapnwebBuffer {
    data: Vec<u8>,
}

#[wasm_bindgen]
impl CapnwebBuffer {
    /// Create a new empty buffer
    #[wasm_bindgen(constructor)]
    pub fn new() -> CapnwebBuffer {
        CapnwebBuffer { data: Vec::new() }
    }

    /// Create a buffer with pre-allocated capacity
    pub fn with_capacity(capacity: usize) -> CapnwebBuffer {
        CapnwebBuffer {
            data: Vec::with_capacity(capacity)
        }
    }

    /// Get the current buffer length
    pub fn len(&self) -> usize {
        self.data.len()
    }

    /// Check if buffer is empty
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }

    /// Write an i32 to the buffer (little-endian)
    pub fn write_i32(&mut self, value: i32) {
        self.data.extend_from_slice(&value.to_le_bytes());
    }

    /// Write an i64 to the buffer (little-endian)
    pub fn write_i64(&mut self, value: i64) {
        self.data.extend_from_slice(&value.to_le_bytes());
    }

    /// Write a string to the buffer (length-prefixed)
    pub fn write_string(&mut self, value: &str) {
        let bytes = value.as_bytes();
        self.write_i32(bytes.len() as i32);
        self.data.extend_from_slice(bytes);
    }

    /// Get the buffer as a pointer for WASM memory access
    pub fn as_ptr(&self) -> *const u8 {
        self.data.as_ptr()
    }

    /// Clear the buffer
    pub fn clear(&mut self) {
        self.data.clear();
    }
}

impl Default for CapnwebBuffer {
    fn default() -> Self {
        Self::new()
    }
}

/// Capnweb reader for deserializing incoming messages
#[wasm_bindgen]
pub struct CapnwebReader {
    data: Vec<u8>,
    position: usize,
}

#[wasm_bindgen]
impl CapnwebReader {
    /// Create a reader from raw bytes
    #[wasm_bindgen(constructor)]
    pub fn new(data: Vec<u8>) -> CapnwebReader {
        CapnwebReader { data, position: 0 }
    }

    /// Read an i32 from the buffer
    pub fn read_i32(&mut self) -> Option<i32> {
        if self.position + 4 > self.data.len() {
            return None;
        }
        let bytes: [u8; 4] = self.data[self.position..self.position + 4]
            .try_into()
            .ok()?;
        self.position += 4;
        Some(i32::from_le_bytes(bytes))
    }

    /// Read an i64 from the buffer
    pub fn read_i64(&mut self) -> Option<i64> {
        if self.position + 8 > self.data.len() {
            return None;
        }
        let bytes: [u8; 8] = self.data[self.position..self.position + 8]
            .try_into()
            .ok()?;
        self.position += 8;
        Some(i64::from_le_bytes(bytes))
    }

    /// Read a length-prefixed string from the buffer
    pub fn read_string(&mut self) -> Option<String> {
        let len = self.read_i32()? as usize;
        if self.position + len > self.data.len() {
            return None;
        }
        let s = String::from_utf8(self.data[self.position..self.position + len].to_vec()).ok()?;
        self.position += len;
        Some(s)
    }

    /// Check if there's more data to read
    pub fn has_more(&self) -> bool {
        self.position < self.data.len()
    }

    /// Get remaining bytes count
    pub fn remaining(&self) -> usize {
        self.data.len().saturating_sub(self.position)
    }
}

// ============================================================================
// Memory management for WASM
// ============================================================================

/// Allocate memory in WASM linear memory
/// Used by the host to allocate space for passing data
#[no_mangle]
pub extern "C" fn alloc(size: usize) -> *mut u8 {
    let mut buf = Vec::with_capacity(size);
    let ptr = buf.as_mut_ptr();
    std::mem::forget(buf);
    ptr
}

/// Free previously allocated memory
#[no_mangle]
pub extern "C" fn dealloc(ptr: *mut u8, size: usize) {
    unsafe {
        let _ = Vec::from_raw_parts(ptr, 0, size);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }

    #[test]
    fn test_subtract() {
        assert_eq!(subtract(5, 3), 2);
        assert_eq!(subtract(3, 5), -2);
    }

    #[test]
    fn test_multiply() {
        assert_eq!(multiply(4, 5), 20);
        assert_eq!(multiply(-2, 3), -6);
    }

    #[test]
    fn test_identity() {
        assert_eq!(identity(42), 42);
        assert_eq!(identity(-1), -1);
    }

    #[test]
    fn test_get_answer() {
        assert_eq!(get_answer(), 42);
    }

    #[test]
    fn test_capnweb_buffer() {
        let mut buf = CapnwebBuffer::new();
        assert!(buf.is_empty());

        buf.write_i32(42);
        assert_eq!(buf.len(), 4);

        buf.write_string("hello");
        assert_eq!(buf.len(), 4 + 4 + 5); // i32 + length prefix + string bytes
    }

    #[test]
    fn test_capnweb_reader() {
        let mut buf = CapnwebBuffer::new();
        buf.write_i32(42);
        buf.write_string("hello");

        let mut reader = CapnwebReader::new(buf.data.clone());
        assert_eq!(reader.read_i32(), Some(42));
        assert_eq!(reader.read_string(), Some("hello".to_string()));
        assert!(!reader.has_more());
    }
}
