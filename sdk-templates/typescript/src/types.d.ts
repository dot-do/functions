/**
 * Auto-generated type definitions for my-function
 *
 * This file is generated by the Functions.do SDK compiler.
 * It provides type definitions for the function's public API.
 *
 * Generated by Functions.do SDK Compiler
 * @module my-function/types
 */

import { RpcTarget } from '@dotdo/functions'

// ============================================================================
// Request/Response Types
// ============================================================================

/**
 * Request body for the greet endpoint
 */
export interface GreetRequest {
  /** The name of the person to greet */
  name: string
}

/**
 * Response from the greet endpoint
 */
export interface GreetResponse {
  /** The greeting message */
  message: string
  /** ISO timestamp when the greeting was generated */
  timestamp: string
}

/**
 * Result of a math operation
 */
export interface MathResult {
  /** The operation that was performed (add, multiply, etc.) */
  operation: string
  /** The operands used in the operation */
  operands: number[]
  /** The result of the operation */
  result: number
}

// ============================================================================
// RPC Target Type Definitions
// ============================================================================

/**
 * Interface defining the function implementations
 */
export interface MyFunctionTargetFunctions {
  greet(name: string): Promise<GreetResponse>
  echo<T>(input: T): Promise<T>
  getTime(): Promise<string>
  add(a: number, b: number): Promise<MathResult>
  multiply(a: number, b: number): Promise<MathResult>
}

/**
 * Interface defining all available RPC methods (including metrics)
 */
export interface MyFunctionTargetMethods extends MyFunctionTargetFunctions {
  /**
   * Greet a user by name
   * @param name - The name to greet
   * @returns A greeting response with message and timestamp
   */
  greet(name: string): Promise<GreetResponse>

  /**
   * Echo the input back unchanged
   * @param input - Any value to echo
   * @returns The same value
   */
  echo<T>(input: T): Promise<T>

  /**
   * Get the current server time
   * @returns ISO timestamp string
   */
  getTime(): Promise<string>

  /**
   * Add two numbers
   * @param a - First number
   * @param b - Second number
   * @returns Math result with operation details
   */
  add(a: number, b: number): Promise<MathResult>

  /**
   * Multiply two numbers
   * @param a - First number
   * @param b - Second number
   * @returns Math result with operation details
   */
  multiply(a: number, b: number): Promise<MathResult>

  /**
   * Get current metrics for this RPC target
   * @returns Object with requestCount, errorCount, and latencyMs
   */
  getMetrics(): { requestCount: number; errorCount: number; latencyMs: number[] }
}

/**
 * Trace span information for distributed tracing
 */
export interface TraceSpan {
  traceId: string
  spanId: string
  method: string
  startTime: number
  endTime?: number
  error?: string
}

/**
 * RPC Target class that can be used for Worker-to-Worker communication
 *
 * This class provides:
 * - Type-safe method invocation
 * - Distributed tracing support
 * - Performance metrics collection
 * - Parameter validation
 * - Automatic resource cleanup via Symbol.dispose
 */
export declare class MyFunctionTarget extends RpcTarget implements MyFunctionTargetMethods {
  constructor(env: Env, functions: MyFunctionTargetFunctions)

  /** Set the trace ID for distributed tracing */
  setTraceId(traceId: string): this

  /** Get collected trace spans */
  getTraceSpans(): TraceSpan[]

  greet(name: string): Promise<GreetResponse>
  echo<T>(input: T): Promise<T>
  getTime(): Promise<string>
  add(a: number, b: number): Promise<MathResult>
  multiply(a: number, b: number): Promise<MathResult>
  getMetrics(): { requestCount: number; errorCount: number; latencyMs: number[] }

  [Symbol.dispose](): void
}

// Legacy alias for backwards compatibility
export type MyFunctionTargetMethods = MyFunctionTargetMethods
export declare class MyFunctionTarget extends MyFunctionTarget {}

// ============================================================================
// Environment Types
// ============================================================================

/**
 * Base environment interface from Functions.do SDK
 */
export interface FunctionEnv {
  [key: string]: unknown
}

/**
 * Environment bindings for this function
 *
 * Extend this interface to add your KV namespaces, Durable Objects,
 * secrets, and environment variables.
 */
export interface Env extends FunctionEnv {
  // Add your bindings here:
  // MY_KV: KVNamespace
  // MY_DO: DurableObjectNamespace
  // API_KEY: string
}

// ============================================================================
// RPC Protocol Types
// ============================================================================

/**
 * RPC request format (JSON-RPC-like)
 */
export interface RpcRequest {
  /** Method name to invoke */
  method: string
  /** Method parameters as an array */
  params: unknown[]
  /** Optional request ID for correlation */
  id?: string
}

/**
 * RPC success response
 */
export interface RpcSuccessResponse {
  /** Request ID if provided */
  id?: string
  /** Method result */
  result: unknown
}

/**
 * RPC error response
 */
export interface RpcErrorResponse {
  /** Request ID if provided */
  id?: string
  /** Error message */
  error: string
  /** Error code */
  code: 'PARSE_ERROR' | 'INVALID_REQUEST' | 'METHOD_NOT_FOUND' | 'METHOD_NOT_ALLOWED' | 'INTERNAL_ERROR'
}

/**
 * Union type for any RPC response
 */
export type RpcResponse = RpcSuccessResponse | RpcErrorResponse

// ============================================================================
// Exported Function Type
// ============================================================================

/**
 * The main function export type
 */
export interface FunctionExport {
  /** HTTP request handler */
  fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response>
  /** Optional scheduled handler */
  scheduled?(controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void>
  /** Optional queue handler */
  queue?(batch: MessageBatch<unknown>, env: Env, ctx: ExecutionContext): Promise<void>
}

// Default export type
declare const _default: FunctionExport
export default _default
