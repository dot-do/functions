/**
 * capnweb RPC Bindings for {{functionName}}
 *
 * This file provides generated bindings for Worker-to-Worker RPC communication
 * using the capnweb protocol. It enables type-safe method invocation across
 * Cloudflare Workers service bindings.
 *
 * Generated by Functions.do SDK Compiler
 * @module {{functionName}}/bindings
 */

import { RpcTarget } from '@functions.do/sdk'
import type { GreetResponse, MathResult, MyFunctionTargetMethods, Env, RpcRequest, RpcResponse } from './types'

// ============================================================================
// RPC Client
// ============================================================================

/**
 * RPC Client for invoking methods on a remote {{functionName}} instance.
 *
 * Use this client to call methods on a function via service binding
 * or direct fetch.
 *
 * @example
 * ```typescript
 * // Using service binding
 * const client = new {{functionName}}Client(env.MY_FUNCTION)
 * const greeting = await client.greet('World')
 * console.log(greeting.message) // "Hello, World!"
 *
 * // Using direct fetch
 * const client = new {{functionName}}Client('https://my-function.workers.dev')
 * const result = await client.add(2, 3)
 * console.log(result.result) // 5
 * ```
 */
export class FunctionClient implements MyFunctionTargetMethods {
  private target: Fetcher | string
  private baseUrl: string

  /**
   * Create a new RPC client
   *
   * @param target - Either a Fetcher (service binding) or a URL string
   */
  constructor(target: Fetcher | string) {
    this.target = target
    this.baseUrl = typeof target === 'string' ? target : ''
  }

  /**
   * Make an RPC call to the target
   */
  private async call<T>(method: string, params: unknown[] = []): Promise<T> {
    const body: RpcRequest = { method, params, id: crypto.randomUUID() }

    let response: Response

    if (typeof this.target === 'string') {
      // Direct fetch
      response = await fetch(`${this.target}/rpc`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
    } else {
      // Service binding
      response = await this.target.fetch('http://internal/rpc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
    }

    const result = (await response.json()) as RpcResponse

    if ('error' in result) {
      throw new RpcError(result.error, result.code, result.id)
    }

    return result.result as T
  }

  /**
   * Greet a user by name
   */
  async greet(name: string): Promise<GreetResponse> {
    return this.call<GreetResponse>('greet', [name])
  }

  /**
   * Echo the input back
   */
  async echo<T>(input: T): Promise<T> {
    return this.call<T>('echo', [input])
  }

  /**
   * Get the current time
   */
  async getTime(): Promise<string> {
    return this.call<string>('getTime', [])
  }

  /**
   * Add two numbers
   */
  async add(a: number, b: number): Promise<MathResult> {
    return this.call<MathResult>('add', [a, b])
  }

  /**
   * Multiply two numbers
   */
  async multiply(a: number, b: number): Promise<MathResult> {
    return this.call<MathResult>('multiply', [a, b])
  }

  /**
   * Get current metrics
   */
  getMetrics(): { requestCount: number; errorCount: number } {
    // Note: This is synchronous and returns local state only
    // To get remote metrics, use: this.call('getMetrics', [])
    return { requestCount: 0, errorCount: 0 }
  }

  /**
   * Get remote metrics (async version)
   */
  async getRemoteMetrics(): Promise<{ requestCount: number; errorCount: number }> {
    return this.call<{ requestCount: number; errorCount: number }>('getMetrics', [])
  }
}

// ============================================================================
// RPC Error
// ============================================================================

/**
 * Error thrown when an RPC call fails
 */
export class RpcError extends Error {
  /** Error code */
  readonly code: string
  /** Request ID if available */
  readonly requestId?: string

  constructor(message: string, code: string, requestId?: string) {
    super(message)
    this.name = 'RpcError'
    this.code = code
    this.requestId = requestId
  }

  /**
   * Check if this error is a specific type
   */
  is(code: string): boolean {
    return this.code === code
  }

  /**
   * Check if this is a method not found error
   */
  get isMethodNotFound(): boolean {
    return this.code === 'METHOD_NOT_FOUND'
  }

  /**
   * Check if this is a parse error
   */
  get isParseError(): boolean {
    return this.code === 'PARSE_ERROR'
  }

  /**
   * Check if this is an internal error
   */
  get isInternalError(): boolean {
    return this.code === 'INTERNAL_ERROR'
  }
}

// ============================================================================
// Type Guards
// ============================================================================

/**
 * Type guard to check if a response is an error
 */
export function isRpcError(response: RpcResponse): response is { id?: string; error: string; code: string } {
  return 'error' in response
}

/**
 * Type guard to check if a response is successful
 */
export function isRpcSuccess(response: RpcResponse): response is { id?: string; result: unknown } {
  return 'result' in response
}

// ============================================================================
// Helpers
// ============================================================================

/**
 * Create an RPC client from environment bindings
 *
 * @param env - Environment with service bindings
 * @param bindingName - Name of the service binding
 * @returns RPC client
 *
 * @example
 * ```typescript
 * const client = createClient(env, 'MY_FUNCTION')
 * const greeting = await client.greet('World')
 * ```
 */
export function createClient(env: Record<string, unknown>, bindingName: string): FunctionClient {
  const binding = env[bindingName]
  if (!binding || typeof (binding as Fetcher).fetch !== 'function') {
    throw new Error(`Service binding '${bindingName}' not found or invalid`)
  }
  return new FunctionClient(binding as Fetcher)
}

/**
 * Create an RPC client from a URL
 *
 * @param url - URL of the function
 * @returns RPC client
 *
 * @example
 * ```typescript
 * const client = createClientFromUrl('https://my-function.workers.dev')
 * const greeting = await client.greet('World')
 * ```
 */
export function createClientFromUrl(url: string): FunctionClient {
  return new FunctionClient(url)
}

// ============================================================================
// Batch Operations
// ============================================================================

/**
 * Batch RPC request for making multiple calls at once
 */
export interface BatchRequest {
  method: string
  params: unknown[]
}

/**
 * Result of a batch operation
 */
export interface BatchResult<T> {
  success: boolean
  result?: T
  error?: string
  code?: string
}

/**
 * Execute multiple RPC calls in a batch
 *
 * This is more efficient than making individual calls when you need
 * to invoke multiple methods.
 *
 * @param client - The RPC client
 * @param requests - Array of batch requests
 * @returns Array of batch results
 *
 * @example
 * ```typescript
 * const results = await batchCall(client, [
 *   { method: 'greet', params: ['Alice'] },
 *   { method: 'greet', params: ['Bob'] },
 *   { method: 'add', params: [1, 2] },
 * ])
 * ```
 */
export async function batchCall<T>(client: FunctionClient, requests: BatchRequest[]): Promise<BatchResult<T>[]> {
  // Execute all requests in parallel
  const promises = requests.map(async (req): Promise<BatchResult<T>> => {
    try {
      const result = await (client as Record<string, Function>)[req.method](...req.params)
      return { success: true, result: result as T }
    } catch (error) {
      if (error instanceof RpcError) {
        return { success: false, error: error.message, code: error.code }
      }
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
    }
  })

  return Promise.all(promises)
}

// Export types
export type { GreetResponse, MathResult, MyFunctionTargetMethods, Env, RpcRequest, RpcResponse }
