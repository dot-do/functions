/**
 * Auto-generated RPC Stub for {{FunctionName}}
 *
 * This client provides type-safe RPC method invocation with:
 * - Parameter validation
 * - Automatic retry with exponential backoff
 * - Full TypeScript type safety
 *
 * Generated by Functions.do SDK Compiler
 * @module {{functionName}}/stub
 */

import type { GreetResponse, MathResult, {{FunctionName}}TargetMethods, RpcRequest, RpcResponse } from './types'

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Retry configuration for RPC calls
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  maxAttempts: number
  /** Initial delay in ms */
  initialDelay: number
  /** Maximum delay in ms */
  maxDelay: number
  /** Backoff multiplier */
  backoffMultiplier: number
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 3,
  initialDelay: 100,
  maxDelay: 5000,
  backoffMultiplier: 2,
}

// ============================================================================
// Error Types
// ============================================================================

/**
 * Error thrown when an RPC call fails
 */
export class {{FunctionName}}StubError extends Error {
  readonly code: string
  readonly requestId?: string

  constructor(message: string, code: string, requestId?: string) {
    super(message)
    this.name = '{{FunctionName}}StubError'
    this.code = code
    this.requestId = requestId
  }

  get isMethodNotFound(): boolean {
    return this.code === 'METHOD_NOT_FOUND'
  }
  get isInvalidParams(): boolean {
    return this.code === 'INVALID_PARAMS'
  }
  get isInternalError(): boolean {
    return this.code === 'INTERNAL_ERROR'
  }
  get isTimeout(): boolean {
    return this.code === 'TIMEOUT'
  }
}

// ============================================================================
// Stub Client
// ============================================================================

/**
 * RPC Stub client for {{FunctionName}}
 *
 * Provides type-safe remote procedure calls with automatic retry
 * and comprehensive error handling.
 *
 * @example
 * ```typescript
 * // Using service binding
 * const stub = new {{FunctionName}}Stub(env.MY_SERVICE)
 * const result = await stub.greet('World')
 * console.log(result.message) // "Hello, World!"
 *
 * // Using URL
 * const stub = {{FunctionName}}Stub.fromUrl('https://{{functionName}}.workers.dev')
 * const sum = await stub.add(2, 3)
 * console.log(sum.result) // 5
 *
 * // With custom retry configuration
 * const stub = new {{FunctionName}}Stub(env.MY_SERVICE, {
 *   maxAttempts: 5,
 *   initialDelay: 200,
 * })
 * ```
 */
export class {{FunctionName}}Stub implements {{FunctionName}}TargetMethods {
  private _target: Fetcher | string
  private _requestCount = 0
  private _errorCount = 0
  private _retryConfig: RetryConfig

  constructor(target: Fetcher | string, retryConfig?: Partial<RetryConfig>) {
    this._target = target
    this._retryConfig = { ...DEFAULT_RETRY_CONFIG, ...retryConfig }
  }

  /**
   * Create a stub from a URL
   */
  static fromUrl(url: string, retryConfig?: Partial<RetryConfig>): {{FunctionName}}Stub {
    return new {{FunctionName}}Stub(url, retryConfig)
  }

  /**
   * Create a stub from a service binding
   */
  static fromBinding(binding: Fetcher, retryConfig?: Partial<RetryConfig>): {{FunctionName}}Stub {
    return new {{FunctionName}}Stub(binding, retryConfig)
  }

  /**
   * Make a raw RPC call
   */
  private async _call<T>(method: string, params: unknown[]): Promise<T> {
    this._requestCount++
    const id = crypto.randomUUID()
    const body: RpcRequest = { method, params, id }

    let response: Response
    if (typeof this._target === 'string') {
      response = await fetch(`${this._target}/rpc`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
    } else {
      response = await this._target.fetch('http://internal/rpc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
    }

    const result = (await response.json()) as RpcResponse

    if ('error' in result) {
      this._errorCount++
      throw new {{FunctionName}}StubError(result.error, result.code, result.id)
    }

    return result.result as T
  }

  /**
   * Make an RPC call with automatic retry
   */
  private async _callWithRetry<T>(method: string, params: unknown[]): Promise<T> {
    let lastError: Error | null = null
    let delay = this._retryConfig.initialDelay

    for (let attempt = 0; attempt < this._retryConfig.maxAttempts; attempt++) {
      try {
        return await this._call<T>(method, params)
      } catch (error) {
        lastError = error as Error
        // Don't retry on client errors
        if (error instanceof {{FunctionName}}StubError && (error.isInvalidParams || error.isMethodNotFound)) {
          throw error
        }
        if (attempt < this._retryConfig.maxAttempts - 1) {
          await new Promise((r) => setTimeout(r, delay))
          delay = Math.min(delay * this._retryConfig.backoffMultiplier, this._retryConfig.maxDelay)
        }
      }
    }

    throw lastError
  }

  // ============================================================================
  // RPC Methods
  // ============================================================================

  /**
   * Greet a user by name
   *
   * @param name - The name to greet
   * @returns A greeting response with message and timestamp
   */
  async greet(name: string): Promise<GreetResponse> {
    if (name === undefined || name === null) {
      throw new {{FunctionName}}StubError('Parameter "name" is required', 'INVALID_PARAMS')
    }
    return this._callWithRetry<GreetResponse>('greet', [name])
  }

  /**
   * Echo the input back unchanged
   *
   * @param input - Any value to echo
   * @returns The same value
   */
  async echo<T>(input: T): Promise<T> {
    return this._callWithRetry<T>('echo', [input])
  }

  /**
   * Get the current server time
   *
   * @returns ISO timestamp string
   */
  async getTime(): Promise<string> {
    return this._callWithRetry<string>('getTime', [])
  }

  /**
   * Add two numbers
   *
   * @param a - First number
   * @param b - Second number
   * @returns Math result with operation details
   */
  async add(a: number, b: number): Promise<MathResult> {
    if (a === undefined || a === null) {
      throw new {{FunctionName}}StubError('Parameter "a" is required', 'INVALID_PARAMS')
    }
    if (b === undefined || b === null) {
      throw new {{FunctionName}}StubError('Parameter "b" is required', 'INVALID_PARAMS')
    }
    return this._callWithRetry<MathResult>('add', [a, b])
  }

  /**
   * Multiply two numbers
   *
   * @param a - First number
   * @param b - Second number
   * @returns Math result with operation details
   */
  async multiply(a: number, b: number): Promise<MathResult> {
    if (a === undefined || a === null) {
      throw new {{FunctionName}}StubError('Parameter "a" is required', 'INVALID_PARAMS')
    }
    if (b === undefined || b === null) {
      throw new {{FunctionName}}StubError('Parameter "b" is required', 'INVALID_PARAMS')
    }
    return this._callWithRetry<MathResult>('multiply', [a, b])
  }

  /**
   * Get current metrics from the remote target
   */
  async getMetrics(): Promise<{ requestCount: number; errorCount: number }> {
    return this._callWithRetry<{ requestCount: number; errorCount: number }>('getMetrics', [])
  }

  /**
   * Get local client metrics
   */
  getLocalMetrics(): { requestCount: number; errorCount: number } {
    return { requestCount: this._requestCount, errorCount: this._errorCount }
  }
}

// ============================================================================
// Batch Operations
// ============================================================================

/**
 * Batch RPC request
 */
export interface BatchRequest {
  method: keyof {{FunctionName}}TargetMethods
  params: unknown[]
}

/**
 * Batch result
 */
export interface BatchResult<T> {
  success: boolean
  result?: T
  error?: string
  code?: string
}

/**
 * Execute multiple RPC calls in parallel
 *
 * @param stub - The RPC stub client
 * @param requests - Array of batch requests
 * @returns Array of batch results
 *
 * @example
 * ```typescript
 * const results = await batchCall(stub, [
 *   { method: 'greet', params: ['Alice'] },
 *   { method: 'greet', params: ['Bob'] },
 *   { method: 'add', params: [1, 2] },
 * ])
 * ```
 */
export async function batchCall<T>(stub: {{FunctionName}}Stub, requests: BatchRequest[]): Promise<BatchResult<T>[]> {
  const promises = requests.map(async (req): Promise<BatchResult<T>> => {
    try {
      const result = await (stub as Record<string, Function>)[req.method](...req.params)
      return { success: true, result: result as T }
    } catch (error) {
      if (error instanceof {{FunctionName}}StubError) {
        return { success: false, error: error.message, code: error.code }
      }
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
    }
  })

  return Promise.all(promises)
}

// Export types
export type { GreetResponse, MathResult, {{FunctionName}}TargetMethods }
