/**
 * Type Stub Generator for Python Functions
 *
 * Generates .pyi type stubs for Python code to provide IDE support
 * for type checking and autocompletion when working with Functions.do.
 */

import type { ParsedPythonModule, PythonFunction, PythonClass, PythonType } from './capnweb-bindings'
import { parsePythonSource } from './capnweb-bindings'

/**
 * Options for type stub generation
 */
export interface TypeStubOptions {
  /**
   * Include docstrings in stubs
   */
  includeDocstrings?: boolean

  /**
   * Include private methods/functions (starting with _)
   */
  includePrivate?: boolean

  /**
   * Add type: ignore comments for dynamic types
   */
  addTypeIgnore?: boolean

  /**
   * Generate stubs for imports
   */
  stubImports?: boolean
}

/**
 * Generate parameter type annotation string
 */
function formatParamType(type: PythonType): string {
  if (type.optional && type.defaultValue) {
    return `${type.pythonType} = ${type.defaultValue}`
  }
  if (type.optional) {
    return `${type.pythonType} = ...`
  }
  return type.pythonType
}

/**
 * Format a docstring for a stub file
 */
function formatDocstring(docstring: string | undefined, indent: string): string {
  if (!docstring) return ''

  const lines = docstring.split('\n')
  if (lines.length === 1) {
    return `${indent}"""${docstring}"""\n`
  }

  const formatted = lines.map((line, i) => {
    if (i === 0) return `${indent}"""${line}`
    if (i === lines.length - 1) return `${indent}${line}"""`
    return `${indent}${line}`
  })

  return formatted.join('\n') + '\n'
}

/**
 * Generate a function stub
 */
function generateFunctionStub(
  func: PythonFunction,
  options: TypeStubOptions,
  indent: string = ''
): string {
  const lines: string[] = []

  // Add docstring
  if (options.includeDocstrings && func.docstring) {
    // Add function signature first
    const asyncPrefix = func.isAsync ? 'async ' : ''
    const selfParam = func.isMethod ? 'self, ' : ''
    const params = func.params
      .map((p) => `${p.name}: ${formatParamType(p.type)}`)
      .join(', ')
    const returnType = func.returnType.pythonType || 'None'

    lines.push(`${indent}${asyncPrefix}def ${func.name}(${selfParam}${params}) -> ${returnType}:`)
    lines.push(formatDocstring(func.docstring, indent + '    '))
    lines.push(`${indent}    ...`)
  } else {
    const asyncPrefix = func.isAsync ? 'async ' : ''
    const selfParam = func.isMethod ? 'self, ' : ''
    const params = func.params
      .map((p) => `${p.name}: ${formatParamType(p.type)}`)
      .join(', ')
    const returnType = func.returnType.pythonType || 'None'

    lines.push(`${indent}${asyncPrefix}def ${func.name}(${selfParam}${params}) -> ${returnType}: ...`)
  }

  return lines.join('\n')
}

/**
 * Generate a class stub
 */
function generateClassStub(cls: PythonClass, options: TypeStubOptions): string {
  const lines: string[] = []

  // Class declaration
  const bases = cls.bases.length > 0 ? `(${cls.bases.join(', ')})` : ''
  lines.push(`class ${cls.name}${bases}:`)

  // Add docstring
  if (options.includeDocstrings && cls.docstring) {
    lines.push(formatDocstring(cls.docstring, '    '))
  }

  // Add methods
  if (cls.methods.length === 0) {
    lines.push('    ...')
  } else {
    for (const method of cls.methods) {
      if (!options.includePrivate && method.name.startsWith('_')) {
        continue
      }
      lines.push(generateFunctionStub(method, options, '    '))
      lines.push('')
    }
  }

  return lines.join('\n')
}

/**
 * Generate Python type stubs (.pyi) from Python source code
 */
export function generateTypeStubs(code: string, options: TypeStubOptions = {}): string {
  const parsed = parsePythonSource(code)
  return generateTypeStubsFromParsed(parsed, options)
}

/**
 * Generate Python type stubs from parsed module
 */
export function generateTypeStubsFromParsed(
  module: ParsedPythonModule,
  options: TypeStubOptions = {}
): string {
  const {
    includeDocstrings = true,
    includePrivate = false,
    addTypeIgnore = false,
    stubImports = true,
  } = options

  const lines: string[] = []

  // Header
  lines.push('# Auto-generated type stubs for Functions.do Python function')
  lines.push('# DO NOT EDIT - Generated by functions-do')
  lines.push('')

  // Common imports
  lines.push('from __future__ import annotations')
  lines.push('')
  lines.push('from typing import Any, Dict, List, Optional, Union, Callable, Awaitable')
  lines.push('')

  // Generate import stubs if requested
  if (stubImports) {
    const uniqueImports = [...new Set(module.imports)]
    for (const imp of uniqueImports) {
      // Skip standard library and typing imports
      if (
        ['typing', 'collections', 'abc', 'dataclasses', 'enum'].includes(imp) ||
        imp.startsWith('typing')
      ) {
        continue
      }
      lines.push(`# import ${imp}`)
    }
    if (uniqueImports.length > 0) {
      lines.push('')
    }
  }

  // Generate stubs for top-level functions
  for (const func of module.functions) {
    if (!includePrivate && func.name.startsWith('_')) {
      continue
    }
    lines.push(generateFunctionStub(func, { includeDocstrings, includePrivate, addTypeIgnore }, ''))
    lines.push('')
  }

  // Generate stubs for classes
  for (const cls of module.classes) {
    lines.push(generateClassStub(cls, { includeDocstrings, includePrivate, addTypeIgnore }))
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Generate JavaScript/TypeScript type definitions from Python code
 * This provides IDE support for calling Python from JS
 */
export function generateJSTypeDefinitions(code: string): string {
  const parsed = parsePythonSource(code)
  const lines: string[] = []

  lines.push('/**')
  lines.push(' * Type definitions for Python function')
  lines.push(' * Auto-generated by functions-do')
  lines.push(' */')
  lines.push('')

  // Map Python types to JS/TS types
  function mapType(pythonType: string): string {
    const typeMap: Record<string, string> = {
      str: 'string',
      int: 'number',
      float: 'number',
      bool: 'boolean',
      None: 'null',
      NoneType: 'null',
      Any: 'any',
      bytes: 'Uint8Array',
    }

    if (pythonType in typeMap) {
      return typeMap[pythonType]
    }

    // Handle list[T]
    const listMatch = pythonType.match(/^(?:list|List)\[(.+)\]$/i)
    if (listMatch) {
      return `${mapType(listMatch[1])}[]`
    }

    // Handle dict[K, V]
    const dictMatch = pythonType.match(/^(?:dict|Dict)\[(.+),\s*(.+)\]$/i)
    if (dictMatch) {
      return `Record<${mapType(dictMatch[1])}, ${mapType(dictMatch[2])}>`
    }

    // Handle Optional[T]
    const optMatch = pythonType.match(/^Optional\[(.+)\]$/i)
    if (optMatch) {
      return `${mapType(optMatch[1])} | null`
    }

    return 'unknown'
  }

  // Generate function types
  for (const func of parsed.functions) {
    const params = func.params
      .map((p) => {
        const opt = p.type.optional ? '?' : ''
        return `${p.name}${opt}: ${mapType(p.type.pythonType)}`
      })
      .join(', ')
    const returnType = mapType(func.returnType.pythonType)
    const asyncReturn = func.isAsync ? `Promise<${returnType}>` : returnType

    if (func.docstring) {
      lines.push(`/** ${func.docstring} */`)
    }
    lines.push(`export function ${func.name}(${params}): ${asyncReturn};`)
    lines.push('')
  }

  // Generate class types
  for (const cls of parsed.classes) {
    if (cls.docstring) {
      lines.push(`/** ${cls.docstring} */`)
    }
    const extendsClause = cls.bases.length > 0 ? ` extends ${cls.bases[0]}` : ''
    lines.push(`export interface ${cls.name}${extendsClause} {`)

    for (const method of cls.methods) {
      const params = method.params
        .map((p) => {
          const opt = p.type.optional ? '?' : ''
          return `${p.name}${opt}: ${mapType(p.type.pythonType)}`
        })
        .join(', ')
      const returnType = mapType(method.returnType.pythonType)
      const asyncReturn = method.isAsync ? `Promise<${returnType}>` : returnType

      if (method.docstring) {
        lines.push(`  /** ${method.docstring} */`)
      }
      lines.push(`  ${method.name}(${params}): ${asyncReturn};`)
    }

    lines.push('}')
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Generate a complete type stub package structure
 */
export interface TypeStubPackage {
  /**
   * Main .pyi stub file content
   */
  stub: string

  /**
   * py.typed marker file (empty)
   */
  pyTyped: string

  /**
   * Package __init__.pyi content
   */
  init: string

  /**
   * TypeScript .d.ts file for JS interop
   */
  dts: string
}

/**
 * Generate a complete type stub package for a Python module
 */
export function generateTypeStubPackage(
  code: string,
  moduleName: string
): TypeStubPackage {
  const stub = generateTypeStubs(code, {
    includeDocstrings: true,
    includePrivate: false,
    stubImports: true,
  })

  const dts = generateJSTypeDefinitions(code)

  const init = `# Type stubs for ${moduleName}
from .handler import *

__all__ = ["handler"]
`

  return {
    stub,
    pyTyped: '', // Empty file marks the package as typed
    init,
    dts,
  }
}

/**
 * Validate type annotations in Python code
 */
export interface TypeValidationResult {
  valid: boolean
  errors: Array<{
    line: number
    message: string
    suggestion?: string
  }>
  warnings: Array<{
    line: number
    message: string
  }>
}

/**
 * Validate Python code for type annotation best practices
 */
export function validateTypeAnnotations(code: string): TypeValidationResult {
  const errors: TypeValidationResult['errors'] = []
  const warnings: TypeValidationResult['warnings'] = []

  const lines = code.split('\n')

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    const lineNum = i + 1

    // Check for missing return type
    const funcMatch = line.match(/^\s*(async\s+)?def\s+(\w+)\s*\([^)]*\)\s*:/)
    if (funcMatch && !line.includes('->')) {
      const funcName = funcMatch[2]
      if (!funcName.startsWith('_')) {
        warnings.push({
          line: lineNum,
          message: `Function "${funcName}" is missing return type annotation`,
        })
      }
    }

    // Check for untyped parameters
    const paramMatch = line.match(/def\s+\w+\s*\(([^)]+)\)/)
    if (paramMatch) {
      const params = paramMatch[1].split(',')
      for (const param of params) {
        const trimmed = param.trim()
        if (trimmed && !trimmed.includes(':') && trimmed !== 'self' && trimmed !== 'cls') {
          if (!trimmed.startsWith('*')) {
            warnings.push({
              line: lineNum,
              message: `Parameter "${trimmed.split('=')[0].trim()}" is missing type annotation`,
            })
          }
        }
      }
    }

    // Check for Any type usage
    if (line.includes(': Any') || line.includes('-> Any')) {
      warnings.push({
        line: lineNum,
        message: 'Using "Any" type reduces type safety - consider more specific types',
      })
    }

    // Check for dict without type params
    if (/:\s*dict\s*[,)]/.test(line) || /:\s*dict\s*=/.test(line)) {
      warnings.push({
        line: lineNum,
        message: 'Bare "dict" type - consider "dict[str, Any]" for better type safety',
      })
    }

    // Check for list without type params
    if (/:\s*list\s*[,)]/.test(line) || /:\s*list\s*=/.test(line)) {
      warnings.push({
        line: lineNum,
        message: 'Bare "list" type - consider "list[T]" for better type safety',
      })
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  }
}
